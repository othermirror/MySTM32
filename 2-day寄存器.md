# ARM Cortex-M4的体系结构

### 1.Cortex-M4总线接口

> ARM Cortex-M4使用了哈佛结构，为系统提供了三套总线

- ***ICode总线***
  - 通过此总线获取指令，访问对象是包含代码的存储器
  - 宽度32bits，取到的指令是只读数据
  - 访问空间：0x0000 0000 ~ 0x1fff ffff（521M）
- ***DCode总线***
  - 通过此总线获取数据，访问的对象是包含代码或数据的存储器
  - 宽度为32bits，制度数据
  - 访问空间：0x0000 0000 ~ 0x1fff ffff（521M）
  - 非对齐的访问会分割为多个对齐的访问
- ***Ststem总线***
  - 用于访问其他系统空间，比如访问硬件控制器
  - 访问空间：0x2000 0000 ~ oxDFFF FFFF 与 0xE010 0000 ~ oxFFFF FFFF

### 2.Cortex-M4的工作状态

> ARM公司设计的CPU可以支持多种指令集
>
> - ARM指令集
>   - 由ARM公司提供，32bits指令，功能强大
>   - 通用汇编指令集（所有的ARM系列CPU都支持）
> - Thumb指令集
>   - Thumb指令集：16bits的指令，功能也强大
>   - Thumb-2指令集：32bits，功能强大，并且增加了不少专用的DSP（数字信号处理）指令
>
> 把Cortex-M4正在执行何种指令集就成为工作状态（处理器状态）ARM状态和Thumb状态

NOTE：Cortex-M4只支持Thumb指令集，因为随之发展Thumb-2慢慢包含了ARM指令集

### 3.Cortex-M的寄存器

> ***寄存器*** ： CPU内部暂时存放数据内容的位置
>
> 按用途可以分为：***通用寄存器*** 、 ***专用寄存器*** 、 ***特殊寄存器***

- ==通用寄存器==
  - 指没有特殊含义、没有特殊用途，我想怎么用就怎么用的寄存器
  - R0 - R7 ： Thumb 和 Thumb-2都可以访问
  - R8 - R12 ： 只有少量的Thumb指令可以访问，ARM和Thumb-2可以全部访问
  - 原因是：一个16bits一个32bits
  
- ==专用寄存器== （R13（SP）、R14（LR）、R15（PC）、xPSR）

  - 指有固定用途的寄存器

  - ***R13（SP） 堆栈指针***

    - 用来保存堆栈的栈顶指针
    - 主要是用来保护数据，在调用函数之前先保存主调函数的数据，防止被被调函数所修改
    - 当被调函数运行完毕后，再恢复主调函数的数据
    - “过程调用”、“现场保护”、“现场恢复”
    - Cortex-M4采用了**双堆栈结构**
      - MSP ： 主堆栈指针，主要是给OS和中断的代码使用的
      - PSP ： 进程堆栈指针，主要是给用户代码使用的

  - ***R14（LR） 链接寄存器***

    - 作用是再执行跳转指令时，LR寄存器会储存跳转指令下一条指令的地址，这个地址就是运行完函数需要接着运行的指令的地址
    - 需要注意的是，当有多次调用时需要注意使用堆栈指针对其进行保护，不然可能丢失

  - ***R15（PC） 程序计数器***

    - 作用是保存下一条指令的地址（0x0000 0000的下一条是0x0000 0004以此类推）
    - 在没有发生任何跳转的情况时，此地址右移2位即是程序执行的指令条数（因为每次移动都是加4）
    - 只是起到一个预取指的作用
    - 改变其的两种方法：随着程序运行自动增加、通过指令去改变（B、BL）

  - ***xPSR***

    - x表示A（应用）、I（中断）、E（执行）

    - 分为应用状态寄存器（APSR）、中断状态寄存器（IPSR）、执行状态寄存器（EPSR）

    - ***应用状态寄存器***

      - > **N** ： 负数标志
        >
        > ​		表示上一条指令执行的结果是否为负数（1 是负数）
        >
        > ​		事实上是直接把结果的符号位直接赋值给N
        >
        > **Z** ：零标志
        >
        > ​		表示上一条指令执行的结果是否为0（1 是为0）
        >
        > **C** ：进位/借位标志
        >
        > ​		如果上一条指令为加法（ADC、ADD、CMN）
        >
        > ​				如果产生了进位则C赋值为1、否则为0
        >
        > ​		如果上一条指令为减法（SBC、SUB、CMP）
        >
        > ​				如果产生了借位则C赋值为0、否则为1
        >
        > ​		所以可以使用这种方法比较大小（减法看是否借位），实际比较大小好像也是这样
        >
        > **V**：溢出标志
        >
        > ​		首先，进位和溢出是毫不相干的，进位未必会溢出，溢出未必会进位
        >
        > ​		运算结果和实际值不一样就是溢出
        >
        > ​		如果有溢出则为1，否则为0
        >
        > ​		CPU判断溢出的方式是：***V = Cn ^ C(n - 1)***
        >
        > ​				Cn为两数最高位相加的进位值
        >
        > ​				C(n - 1)为两数次高位相加的进位值
        >
        > **Q**：饱和标志
        >
        > ​		数字信号处理的一种方式，通过将数据强制置为最大允许值或者最小允许值的防止来减少数据所带来的畸变问题，前提是超出范围别太大
        >
        > ​		如果上一条指令是饱和计算指令且进行了饱和计算则为1， 否则为0
        >
        > ​				如：ADD普通加法、QADD饱和加法
        >
        > **IT**：与if……then……有关，不了解
        >
        > **CI**：
        >
        > ​		只有在特定的指令下才有效
        >
        > ​		在执行LDM（多寄存器加载）、STM（多寄存器存储）操作时，保存被中断打断的进度，中断执行完毕后，处理器会返回由ICI指向的寄存器，并且恢复操作（防止被中断打断后重复操作）
        >
        > **T**
        >
        > ​		表示处理器当前执行的状态
        >
        > ​		0 ： 表示ARM状态，正在执行ARM指令集
        >
        > ​		1 ： 表示Thumb状态，正在执行Thumb指令集
        >
        > ** Exception Number**
        >
        > ​		占xPSR最低的八位，保存中断的编号（Cortex-M4中每个中断对应一个唯一的编号）
  
- ==特殊寄存器==

  - ***中断屏蔽寄存器***

    - 如果不想被中断打断某些操作可以屏蔽某些中断、
      - PRIMASK[0] ： 片上外设的总中断开关，1 屏蔽所有片外外设中断，0 接受
      - FAULTMASK[0] ：系统错误异常的中断总开关，1 屏蔽所有异常， 0 接受
      - BASEPRI  ： 更加灵活的屏蔽，将屏蔽优先级比之低的所有中断，高的继续响应（数值越小优先级越高）

  - ***CONTROL 控制寄存器***

    - 用来控制选择哪个堆栈（主堆栈MSP/进程堆栈PSP）

      - CONTROL[1] : CONTROL寄存器的bit1 ，1 代表选择进程堆栈PSP，0 为主堆栈MSP

    - 用来控制选择线程模式的访问等级（特权等级/非特权等级）

      - > Cortex-M4有两种模式
        >
        > ​	线程模式：程序正常运行的模式、没有中断产生的模式，此模式下CPU的权限时受限的，非特权无法访问硬件设备
        >
        > ​	处理模式：指中断或异常时，CPU被打断，转去执行中断或异常处理函数，此时的CPU拥有特权

      - CONTROL[0]: CONTROL寄存器的bit0 ，1 代表非特权等级，0 为特权等级

