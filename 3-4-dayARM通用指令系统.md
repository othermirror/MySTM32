# ARM汇编程序

> 一个ARM汇编程序，大概由下列三种指令构成(ARM汇编指令、伪指令、宏指令)

### ARM汇编指令

- 由ARM公司设定
- 每一条汇编指令唯一对应一个机器指令
- 汇编指令 = 操作码 + 操作数
  - 操作码：一种操作或者运算（ADD、MOV、SUB等）
  - 操作数： 参与操作的数据（MOV R0，#3的#3）
- 在各个编译器中都是统一的

### 伪指令

- 由编译器厂商提供，没有机器指令与之对应，可以表示程序员的某种操作
- 在每个编译器中都有可能不一样
- 只能被编译器识别，编译完成后目标程序中不会出现伪指令
- 与汇编指令的区别：一个是CPU执行（汇编指令），一个由编译器解释

### 宏指令

- 由编译器厂商提供
- KEIL中的宏指令是由EQU来定义
- 格式为：==标签 EQU 数值== = C语言中的 ==#define 标签 数值==

### Keil汇编文件语句格式

- 标签一定要定格写（标志当前位置）
- 指令空一格写（ARM汇编指令、伪指令、宏指令）
- ；（行注释，不参与编译和运行）
- 上边三者可以任意省略

***



# Keil中编写简单的启动文件

### 1、先创建一个工程

### 2、创建文件以及把这个文件添加到工程内（启动文件命名xxx.s）

### 3、开始编写

- 在linux和STM32中都会对程序进行分段，如堆/栈/.data/.bss/.rodata/.text...

- Keil中定义一个段的伪指令为：***AREA***

  - 格式为：AREA 段名，段属性1，段属性2，...
  - 段名：需要符合C语言命名规则
  - 属性分为：
    - NOINIT ： 表示此段内存不需要初始化
    - CODE ： 表示代码段（只读）
    - DATA ： 表示数据段
    - READWRITE ： 表示可读可写
    - READONLY ： 表示只读
    - ALIGN ： 用来设置对齐方式（ALIGN=3，表示2^3(8)字节对齐）
    - ==注意：==不能同时设置两个互斥的属性。如：CODE和READWRITE

- Keil汇编程序中，必须要有三个段：***堆栈段***、***RESET段***、***代码段***

- **堆栈段**的定义

  - 格式：==AREA My_Stack,NOINIT,READWRITE,ALIGN=3== 

  - My_Stack ： 标签号（堆栈的名字）

  - NOINIT ： 不需要初始化

  - READWRITE ： 可读可写

  - ALIGN=3  : 堆栈段8字节对齐

  - **写完上面的之后开始写堆栈的代码**

    - > ***格式***
      >
      > Stack_Start 	;这是一个标号，表示My_Stack从此处开始。
      >
      > ​	SPACE Stack_Size 	;SPACE x 伪指令，表示开辟x字节的区域，Stack_Size是宏指令定义过i的标签号 	
      >
      > Stack_End 	;这是一个标号，表示My_Stack到此结束。
      >
      > ==注意：==这样写后***Stack_End为栈顶指针***，因为是从下往上定义的，而栈是从上往下存储的，所以最好是可以将Stack_End和Stack_Start 调换位置，调换位置后Stack_Start 将是栈顶指针

  - **一般情况下写完第一句后还需要写下面两句代码：**

    - PRESERVE8 ： 表示之后的代码无特殊说明，都是以8字节对齐 
    - THUMB ： 表示之后的代码无特殊说明，处理器都是Thumb状态

- **RESET段**的定义

  - 作用：用来保存Cortex-M4中断向量表

  - 段名不能修改，只能为***RESET***（因为Keil环境中已经指定了）

  - RRSET段是程序的其实位置，如果是FLASH启动，那么代码就是从RESET段开始执行的

  - 为了让CPU以最快速度找到此数组（中断向量表），我们将它放在一个固定的地址（0x08000000FLASH闪存空间）

  - 格式：==AREA RESET,DATA,READONLY==

  - RESET ： 标签号（不可以修改）

  - DATA ： 数据段

  - READONLY ： 只读

  - **写完上面的之后正式开始写中断向量表**

    - > ***格式：***
      >
      > _Vectors ；标号，表示RESET段从这里开始
      >
      > ​	DCD	栈顶指针（上文的Stack_End ） ；中断向量表的第0个元素必须是栈顶地址
      >
      > ​	DCD	_start     ；中断向量表第1个元素必须是复位，start将在下面出现
      >
      > ​	; 中断处理函数等
      >
      > ​	SPACE 0x400 ； 后面可能还有中断函数需要指定，所以可以先将空间开辟出来留着
      >
      > ==解释：==DCD用来分配一个连续的4字节大小的空间（地址是四个字节）

- **代码段**的定义

  - 格式：==AREA |.text|,CODE,READONLY==

  - |.text| ； 不知道，可以问讲师

  - CODE ： 代码段

  - READONLY ： 只读

  - **写完上面的之后正式开始写代码**

    - > ***格式：***
      >
      > _start PROC
      >
      > ​	MOV R0，#1
      >
      > ​	...
      >
      > ​	ENDP
      >
      > fun1 PROC
      >
      > ​	MOV R1，#2
      >
      > ​	...
      >
      > ​	ENDP
      >
      > ...
      >
      > ​	END
      >
      > ==解释：==标签名后接PROC，与ENDP搭配使用，这两者之间的内容就是执行的代码,END表示段结束

- 上电后的过程

  - 上电或者复位后CPU先找到0x08000000
  - 提取此处的内容（栈顶地址）放置至SP（栈顶指针）寄存器
  - 然后将0x08000004地址处的内容（复位中断处理函数）赋值给PC
  - 然后跳转到复位中断处理函数（PC中储存的）执行代码

*****

# ARM指令的格式

### 1、格式

- ==操作码（条件）（S） 结果寄存器 第一个运算操作时寄存器(Rn) （第二个操作数）==
- 条件：如果省略不写，表示该指令无条件执行， 如MOVEQ判断是否相等（APSR.z）（具体的条件代码见(1)[111]）
- S : 表示指令是否会影响到xPSR的标志位（不加S未必不会影响到xPSR，如：CMP）
- 结果寄存器 ： 结果只能保存在寄存器中
- Rn ： 第一个运算操作数寄存器
- 第二操作数 ：第二操作数的形式是多样的可以是***寄存器***、***立即数***、***寄存器+位移***
- **立即数**
  - 立即数的判断（判断一个数是否是立即数），因为第二操作数只占了12bits，内存相当的拮据
  - 保存格式为：循环右移常数(高4bits)***x*** + 常数部分(低8bits)***y***，立即数=x 循环右移(2 * y)得到的数
  - 换句话说：一个数如果循环左移偶数次（最多为30），如果可以使全部的1处于低八位则是立即数
- **寄存器**
  - 第二个操作数为寄存器，如ADD R0，R1，R2
- **寄存器 + 位移**
  - 位移分为***算数位移(补符号位)***、***逻辑位移***
  - 代码为：
    - LSL #n(逻辑左移n位)
    - LSR #n(逻辑右移n位)
    - ASR #n(算数右移n位)
    - ROR #n(循环右移n位)
    - RRX (带扩展(xPSR.c)的循环右移1位)
  - 用法：MOV R1，R0，LSL #2

*****



# 寻址方式

### 见其他文件()[]

***



# ARM指令

### 1、ARM存储器访问指令

> 用来在存储器与寄存器之间传递数据
>
> 将数据从存储器放到寄存器 称为 加载Loader(LD)
>
> 将数据从寄存器放到存储器 称为 存储Store(ST)

##### 1.单寄存器操作

- ***指令格式：***

  - ***LDR{cond}{S}{B/H} Rd，<存储器地址>*** ；将存储器地址中的数据加载到Rd

  - ***STR{cond}{B/H} Rd，<存储器地址>***；将Rd中的数据存储进存储器地址中去

  - ==解释：==

    - B ：Byte，加载或者存储一个字节的数据
    - H ： 半字，加载或者存储两个字节的数据
    - 默认 ：一字，加载或者存储四个字节的数据
    - S ： 代表有符号的加载（默认无符号）

  - **存储器地址确定方式**

    - ***1.寄存器间接寻址***

      - 存储器地址直接在寄存器中表示
      - 如：STR R1，[R0]；R0中存储了存储器的地址

    - ***2.寄存器偏移寻址***

      - 将寄存器中的地址偏移后，才是最终操作的地址

        - > **表示法**				**访问的存储器地址**	**访问后寄存器中保存的存储器地址**	**意思**
          >
          > [Rn，偏移量]	 Rn + 偏移量				Rn									寄存器保存的地址不变
          >
          > [Rn，偏移量]!	Rn + 偏移量				Rn + 偏移量					寄存器保存的地址会改变
          >
          > [Rn]，偏移量	 Rn								Rn + 偏移量					只改变寄存器保存的地址
          >
          > ==解释：==偏移量可以是立即数和寄存器或者寄存器+位移（STR R7, [R0, R8, LSL #2]



##### 2.多寄存器操作

> 在一个连续的存储器地址上，可以进行多个寄存器的存取

- **指令格式**
  - ***LDM{cond}<模式>  Rn{!}, reglist***
  - ***STM{cond}<模式>  Rn{!}, reglist***
  - ==解释：==
    - Rn是一个寄存器，里面保存的是存储器的地址
    - reglist是寄存器列表，用来保存从存储器中取出的数据(LDM)，或者把这里面的数据存入存储器(STM)，格式为：{R1，R2，R3，LR}与{R1-R3，LR}等效
    - ==模式：==
      - IA ： 传输数据之后，地址自动增加4个字节接着再存储下一个数据
      - IB ： 传输数据之前，地址自动先增减4个字节再存入数据
      - DA ： 传输数据之后，地址自动减少4个字节再接着存储下一个数据
      - DB ： 传输数据之前，地址自动先减少4个字节再存入数据
      - ==注意：==ARM Cortex-M4只支持IA/DB
    - **！**：表示上述模式过后Rn中的地址是否随之发生改变（默认不改变）
    - LDM和STM可以用于现场保护和现场恢复，不过有点缺陷，需要程序员保持头脑清晰，不建议

##### 3.堆栈指令

- PUSH 寄存器/寄存器列表	；入栈操作，将（列表中所有）寄存器入栈保存（现场保护实现原理）
- POP 寄存器/寄存器列表	；出栈操作，从栈顶指针开始取出数据保存至寄存器/寄存器列表中
- 堆栈的四种属性：
  - Add	递增的堆栈，栈地址会增加
  - Dec 递减的堆栈，栈地址会减少
  - Empty 空的， 表示SP所指向的地址中数据内容是空的（不是指堆栈没有数据）
  - Full 满的，表示SP指向的地址中数据内容时满的（不代表堆栈满了）
- 四种属性结合得到四种类型的堆栈
  - EA ：空递增堆栈，先存入数据再移动SP导致SP指向下一个空间（空）
  - FA： 满递减堆栈，先移动Sp再存入数据导致SP指向的空间有数据（满）
  - ED： 空递减堆栈，原理同上
  - FD： 满递减堆栈，原理同上



### 2、数据处理指令

> 只是对寄存器中的数据进行操作

##### 1.数据传送指令

- MOV，MVN（***将第二操作数取反存入***）

  - 例子：MOV R1,#1   ;R1 == 0x01 
  - 例子：MVN R1,#1   ;R1 == 0xFFFFFFFE

- 算数运算指令（加减）

  - 加法
    - ADD（普通加法）、ADC（带进位的加法）
  - 减法（第一操作数减第二操作数）
    - SUB（普通减法）、SBC（带进位的减法）
  - 逆向减法（第二操作数减去第一操作数）
    - RSB{cond}{S} Rd,Rn,operand2   ;逆向减法 operand2 - Rn -> Rd 
    - RSC{cond}{S} Rd,Rn,operand2   ;带借位的逆向减法 

- 逻辑运算指令（按位操作）

  - AND ： 按位与
  - ORR ： 按位或 
  - EOR ： 按位异或
    - ***以上三个的格式都为：EOR{cond}{S} Rd,Rn,operand2***
    - ***将Rn和operand2运算的结果赋值给Rd***
  - BIC ： 按位清零
    - ***格式和上面一样BIC{cond}{S} Rd,Rn,operand2***
    - ***对Rn进行操作但不会改变Rn的值，将运算结果赋值给Rd***
    - ***将Rn中与operand2为1的bit位相对应的位置清零***

- 计较指令

  - CMP
    - 格式：CMP Rn , operand2
    - 作用：比较两个的大小，影响xPSR状态标志位
    - 例子：CMP R0, #1 、MOVEQ R0, #3  ; if(R0 == 1) R0 = 3;
  - CMN（负数比较）
    - 格式：CMN Rn , operand2
    - 作用：比较两个的大小（Rn与**-**operand2），影响xPSR状态标志位
    - 例子：CMN R0, #1  ;把R0 和 -1进行比较
  - TST（测试特定的位是否为0）
    - 格式：TST Rn , operand2 
    - 原理：利用Rn & operand2 对xPSR的状态标志位的影响
    - 例子：TST R1, #1   ;相当于 R1 & 0x01，如果xPSR.Z == 1(意味着运算结果为0)，说明R1的bit0是为0
  - TEQ（测试是否相等）
    - 格式：TEQ Rn , operand2
    - 原理：Rn ^ operand2 来进行判断，如果两个数相等，则xPSR.Z == 1

- 分支指令（实现代码的跳转）

  - 直接向PC寄存器赋值
    - MOV PC，LR ； 下一条跳转到LR进行
  - 分支指令
    - B 标号
      - 用于不带返回的跳转（if，for循环）
    - BL 标号
      - 用于带返回的跳转（过程调用(函数调用)）

- 杂项指令

  - SWI

    - 作用：产生一个软件中断实现特权和非特权的转变
    - 格式：***SWI{cond} immed_24***	;immed_24(24位的立即数)中断编号，整数

  - MRS（查资料）

    - 格式：***MRS Rd, PSR***
    - 作用：将状态寄存器(C/S)PSR的值赋值给Rd

  - MSR （查资料）

    - 将寄存器Rd的值，赋值给程序状态寄存器

    - PSR的控制域

    - > 位 [31 ： 24] 为条件标志位域，用 f 表示；
      > 位 [23 ： 16] 为状态位域，用 s 表示；
      > 位[15 ： 8] 为扩展位域，用 x 表示；
      > 位 [7 ： 0] 为控制位域，用 c 表示；

- 伪指令

  - 主要Keil的伪指令

  - NOP：空操作，占用一个机器周期的时间

  - LDR

    - 格式：LDR{cond} Rd,=expr 

    - 作用：将expr的值赋值给Rd，与MOV功能一样，不过expr不受立即数的影响

    - > LDR R0,=0x12345678

  - DCD/DCB

    - DCD 向当前地址存入一个word（4个字节）

    - DCB 向当前地址存入一个Byte（1个字节）

    - ~~~C
      例子：
          可以实现数组的定义: 
      				a、C语言: char str[] = "abc";
      					翻译成汇编: 
      					str 
      						DCB 'a'
      						DCB 'b'
      						DCB 'c'
      						DCB '\0'
      					or 
      					str 
      						DCB 'a','b','c','\0' 
      						
      				b、C语言: int arr[] = {1,2,3,4,5}
      					翻译成汇编: 
      					arr 
      						DCD 1,2,3,4,5
      						
      				通过: 可以知晓两个数组的各自的地址 
                          LDR R0, =str 
      					LDR R1, =arr
      ~~~

***



# ARM程序设计

### 1、顺序结构

> 从上往下执行

### 2、分支结构

> C语言中if else的实现

~~~C
实例代码: 
			if(a > b)
			{
				a = 1;
			}
			else 
			{
				b = 2;
			}
			
		=> 汇编: 
			假设: 
				a -> 0x20000000 (R0)
				b -> 0x20000004 (R1)
				MOV R3, #1
				MOV R4, #2 
				MOV R2, #0x20000000 
				LDR R0, [R2]   ;a -> R0 
				LDR R1, [R2,#4] ;b -> R1 
				;比较R0和R1的大小关系 
				CMP R0, R1 
				STRGT R3 , [R2]
				STRLE R4, [R2,#4]
~~~

### 3、循环结构

~~~C
C语言例子: 
			int i;
			int sum = 0;
			for(i = 1; i <= 10; i++)
			{
				sum += i;
			}//sum 保存了1~10之和
			
		=> 
汇编实现: 
				用寄存器表示变量
				如: 
					i -> R0 
					sum -> R1 
					
				;求1~10之和 
				;初始化条件 
				MOV R0, #1  ;i = 1
				MOV R1, #0  ;sum = 0 
			for_start	
				;循环体语句 
				CMP R0, #10 
				ADDLE R1, R0, R1 ; sum += i 
				ADDLE R0, R0, #1 ; i++ 
				BLE for_start    ;条件满足的情况下，跳转到循环开始的地方
				
				当循环体语句比较多的时候，每条语句都去写一个条件码，
				比较麻烦!!那么可以反过来思考，当循环条件不满时，是不是
				应该跳出循环??? 
				
优化汇编（另一种方法）：		
                初始化语句 
				MOV R0, #1  ;i = 1
				MOV R1, #0  ;sum = 0 
			for_start 
				CMP R0, #10 
				BGT for_end
				ADD R1, R0, R1 ; sum += i 
				ADD R0, R0, #1 ; i++ 
				B for_start
			for_end 
~~~

### 4、函数的实现

- 函数参数只能用R0-R4这四个寄存器（再多只能存放在栈空间）
- 函数返回通过R0进行返回，如果64bits则R1(高)R0(低)
- 最好是要使用现场保护和现场恢复

- 格式：

- ~~~C
  标号 PROC
      
      PUSH {Rm-Rn， LR}  // 现场保护
  	...
      ...
      MOV R0, 结果	 // 返回结果
      POP {Rm-Rn， LR}		// 现场恢复
      
      ENDP
  ~~~

### 5、汇编和C文件共存

- 汇编文件调用C文件中的函数

  - 在汇编文件中写==IMPORT 函数名==即可调用，（外部声明）
  - 最好写在段声明前面

- C文件调用汇编的函数（过程）

  - 先在汇编文件中写==EXPORT 过程标号==，（声明这个函数其他C文件可以调用）

  - 接着在C文件中按照此函数(过程)声明

    - ~~~C
      例子：
      sum PROC 
          PUSH {R2-R12, LR}
      			;函数体内容 
          CMP R0, R1 
          MOVLT R2, R1
          MOVGE R2, R0 
      
          ;准备返回 
          MOV R0, R2 
          POP {R2-R12, LR}
      	MOV PC, LR
          ENDP 
          
      C文件这样声明
          int sum(int , int ) ;
      ~~~

    - ==解释：==因为返回了一个int的值给R0所以返回值写作int，且传入了两个参数R0、R1所以参数写作两个int，函数名就是标号