# ARM汇编程序

> 一个ARM汇编程序，大概由下列三种指令构成(ARM汇编指令、伪指令、宏指令)

### ARM汇编指令

- 由ARM公司设定
- 每一条汇编指令唯一对应一个机器指令
- 汇编指令 = 操作码 + 操作数
  - 操作码：一种操作或者运算（ADD、MOV、SUB等）
  - 操作数： 参与操作的数据（MOV R0，#3的#3）
- 在各个编译器中都是统一的

### 伪指令

- 由编译器厂商提供，没有机器指令与之对应，可以表示程序员的某种操作
- 在每个编译器中都有可能不一样
- 只能被编译器识别，编译完成后目标程序中不会出现伪指令
- 与汇编指令的区别：一个是CPU执行（汇编指令），一个由编译器解释

### 宏指令

- 由编译器厂商提供
- KEIL中的宏指令是由EQU来定义
- 格式为：==标签 EQU 数值== = C语言中的 ==#define 标签 数值==

### Keil汇编文件语句格式

- 标签一定要定格写（标志当前位置）
- 指令空一格写（ARM汇编指令、伪指令、宏指令）
- ；（行注释，不参与编译和运行）
- 上边三者可以任意省略

# Keil中编写简单的启动文件

### 1.先创建一个工程

### 2.创建文件以及把这个文件添加到工程内（启动文件命名xxx.s）

### 3.开始编写

- 在linux和STM32中都会对程序进行分段，如堆/栈/.data/.bss/.rodata/.text...

- Keil中定义一个段的伪指令为：***AREA***

  - 格式为：AREA 段名，段属性1，段属性2，...
  - 段名：需要符合C语言命名规则
  - 属性分为：
    - NOINIT ： 表示此段内存不需要初始化
    - CODE ： 表示代码段（只读）
    - DATA ： 表示数据段
    - READWRITE ： 表示可读可写
    - READONLY ： 表示只读
    - ALIGN ： 用来设置对齐方式（ALIGN=3，表示2^3(8)字节对齐）
    - ==注意：==不能同时设置两个互斥的属性。如：CODE和READWRITE

- Keil汇编程序中，必须要有三个段：***堆栈段***、***RESET段***、***代码段***

- **堆栈段**的定义

  - 格式：==AREA My_Stack,NOINIT,READWRITE,ALIGN=3== 

  - My_Stack ： 标签号（堆栈的名字）

  - NOINIT ： 不需要初始化

  - READWRITE ： 可读可写

  - ALIGN=3  : 堆栈段8字节对齐

  - **写完上面的之后开始写堆栈的代码**

    - > ***格式***
      >
      > Stack_Start 	;这是一个标号，表示My_Stack从此处开始。
      >
      > ​	SPACE Stack_Size 	;SPACE x 伪指令，表示开辟x字节的区域，Stack_Size是宏指令定义过i的标签号 	
      >
      > Stack_End 	;这是一个标号，表示My_Stack到此结束。
      >
      > ==注意：==这样写后***Stack_End为栈顶指针***，因为是从下往上定义的，而栈是从上往下存储的，所以最好是可以将Stack_End和Stack_Start 调换位置，调换位置后Stack_Start 将是栈顶指针

  - **一般情况下写完第一句后还需要写下面两句代码：**

    - PRESERVE8 ： 表示之后的代码无特殊说明，都是以8字节对齐 
    - THUMB ： 表示之后的代码无特殊说明，处理器都是Thumb状态

- **RESET段**的定义

  - 作用：用来保存Cortex-M4中断向量表

  - 段名不能修改，只能为***RESET***（因为Keil环境中已经指定了）

  - RRSET段是程序的其实位置，如果是FLASH启动，那么代码就是从RESET段开始执行的

  - 为了让CPU以最快速度找到此数组（中断向量表），我们将它放在一个固定的地址（0x08000000FLASH闪存空间）

  - 格式：==AREA RESET,DATA,READONLY==

  - RESET ： 标签号（不可以修改）

  - DATA ： 数据段

  - READONLY ： 只读

  - **写完上面的之后正式开始写中断向量表**

    - > ***格式：***
      >
      > _Vectors ；标号，表示RESET段从这里开始
      >
      > ​	DCD	栈顶指针（上文的Stack_End ） ；中断向量表的第0个元素必须是栈顶地址
      >
      > ​	DCD	_start     ；中断向量表第1个元素必须是复位，start将在下面出现
      >
      > ​	; 中断处理函数等
      >
      > ​	SPACE 0x400 ； 后面可能还有中断函数需要指定，所以可以先将空间开辟出来留着
      >
      > ==解释：==DCD用来分配一个连续的4字节大小的空间（地址是四个字节）

- **代码段**的定义

  - 格式：==AREA |.text|,CODE,READONLY==

  - |.text| ； 不知道，可以问讲师

  - CODE ： 代码段

  - READONLY ： 只读

  - **写完上面的之后正式开始写代码**

    - > ***格式：***
      >
      > _start PROC
      >
      > ​	MOV R0，#1
      >
      > ​	...
      >
      > ​	ENDP
      >
      > fun1 PROC
      >
      > ​	MOV R1，#2
      >
      > ​	...
      >
      > ​	ENDP
      >
      > ...
      >
      > ​	END
      >
      > ==解释：==标签名后接PROC，与ENDP搭配使用，这两者之间的内容就是执行的代码,END表示段结束

- 上电后的过程

  - 上电或者复位后CPU先找到0x08000000
  - 提取此处的内容（栈顶地址）放置至SP（栈顶指针）寄存器
  - 然后将0x08000004地址处的内容（复位中断处理函数）赋值给PC
  - 然后跳转到复位中断处理函数（PC中储存的）执行代码

# ARM指令的格式

### 1.格式

- ==操作码（条件）（S） 结果寄存器 第一个运算操作时寄存器(Rn) （第二个操作数）==
- 条件：如果省略不写，表示该指令无条件执行， 如MOVEQ判断是否相等（APSR.z）（具体的条件代码见(1)[111]）
- S : 表示指令是否会影响到xPSR的标志位（不加S未必不会影响到xPSR，如：CMP）
- 结果寄存器 ： 结果只能保存在寄存器中
- Rn ： 第一个运算操作数寄存器
- 第二操作数 ：第二操作数的形式是多样的可以是***寄存器***、***立即数***、***寄存器+位移***
- **立即数**
  - 立即数的判断（判断一个数是否是立即数），因为第二操作数只占了12bits，内存相当的拮据
  - 保存格式为：循环右移常数(高4bits)***x*** + 常数部分(低8bits)***y***，立即数=x 循环右移(2 * y)得到的数
  - 换句话说：一个数如果循环左移偶数次（最多为30），如果可以使全部的1处于低八位则是立即数
- **寄存器**
  - 第二个操作数为寄存器，如ADD R0，R1，R2
- **寄存器 + 位移**
  - 位移分为***算数位移(补符号位)***、***逻辑位移***
  - 代码为：
    - LSL #n(逻辑左移n位)
    - LSR #n(逻辑右移n位)
    - ASR #n(算数右移n位)
    - ROR #n(循环右移n位)
    - RRX (带扩展(xPSR.c)的循环右移1位)
  - 用法：MOV R1，R0，LSL #2

# 寻址方式

### 见其他文件()[]

# ARM指令

### 1.ARM存储器访问指令

> 用来在存储器与寄存器之间传递数据
>
> 将数据从存储器放到寄存器 称为 加载Loader(LD)
>
> 将数据从寄存器放到存储器 称为 存储Store(ST)

##### 1.单寄存器操作

##### 1.多寄存器操作



